 Ja, die Kamera läuft auch wieder. Wir betrachten den Fall, dass wir das RSA-Verfahren haben. Wir haben gesehen, die Dekodierung klappt wunderbar, wenn nicht dummerweise eine unserer geheimen Primzahlen ein Teiler ist von der zu verschlüsselnden Nachricht. Jetzt wollte ich eben vorführen, dass wenn die verschlüsselte Nachricht, wenn da doch einer dieser geheimen Primfaktoren als Teiler dummerweise drinsteckt, dass die Sache trotzdem nicht schiefgeht. Die Idee war, dass dann unser Euler-Fermat-Satz, der uns vorher ermöglichte, wenn wir so Modulo-M-Rechnungen hatten, unseren Exponenten zu reduzieren, dass das Ganze zwar mit Modulo-M nicht mehr geht, weil M und N nicht mehr teilerfremd sind, aber wenn zum Beispiel der Primfaktor P in M drinsteckt, dann kann nicht gleichzeitig auch Q drinstecken. Das heißt, in dem Moment, wo wir Modulo-Q rechnen, können wir die entsprechende Analogie vom Euler-Fermat Modulo-Q immer noch anwenden, weil Q ist dann immer noch teilerfremd zu unserer Nachricht. Also haben wir uns überlegt, wie klappt das Ganze aus, Modulo-Q sind, wenn wir in die Mitte dieser Folie gucken, haben wir uns überlegt, dass tatsächlich die Nachricht zu verschlüsseln und dann Modulo-Q zu rechnen, kommt das gleiche raus, wie wenn ich die Modulo-N gerechnet hätte, also auch M hoch E Modulo-N, so war das C ja eigentlich definiert, aber wenn ich statt des Modulo-Q rechne, kommt ebenfalls M hoch E und C, das gleiche Modulo-Q gerechnet. Jetzt wollten wir darauf Euler-Fermat anwenden und an der Stelle hing ich dann vor der Pause, weil Euler-Fermat mir eben nur sagt, wenn ich M hoch ED Modulo-Q habe, dann ist dasselbe wie M hoch ED, aber dann eben nur Modulo-Phi von Q und nicht Modulo-Phi von N. Also das, was dann reduziert hängt, hängt von dem ab, bezüglich, was ich modulo gerechnet habe und an der Stelle wollte ich dann, hatte ich dann angesetzt, ihn nachzurechnen, dass ED Modulo-Phi von Q genau dasselbe ergibt, wie ED Modulo-Phi von N und nach einer Stunde, nachdem ich die Pause eben schon so lange schuldig war, habe ich mich nicht getraut und dachte mir, ich gehe mal lieber in die Pause, bevor ich mich da völlig verrenne. Machen wir das Ganze jetzt weiter, denn es klappt tatsächlich, also ED Modulo-Phi von Q zu rechnen, gibt dasselbe wie ED Modulo-Phi von N zu rechnen und der Grund ist einfach der, dass ED Modulo-Phi von N gleich 1 ist, das ist das, was wir wissen, also wir wissen ED Modulo, ich schreibe Ihnen das nochmal so aus, ED Modulo-Phi von N, das ist gleich 1 und das heißt ja nichts anderes, als dass ED irgendeins ist plus irgendein Vielfaches von Pi von N, also E mal D ist irgendein Vielfaches i und irgendein Vielfaches i, sodass E mal D gerade gleich ist 1 plus i mal Pi von N. Ja, Pi von N war aber ja p minus 1, q minus 1, also 1 plus i mal und Pi von N war q minus 1, p minus 1, dasselbe wie Pi von P, Pi von Q, dasselbe wie Pi von P mal Pi von Q. Ja und jetzt sehen Sie was passiert, wenn ich diese Zahl, die da stehe, wenn ich die Modulo-Phi von Q rechne, die ist natürlich auch 1 plus ein Vielfaches von Pi von Q, das heißt die unterscheidet sich von der 1 auch nur um dieses Vielfach hier, nämlich um i mal Pi von P von Pi von Q, also wenn ich von der Zahl so oft Pi von Q abziehe, wie ich kann, dann kommt entsprechend auch gleich 1 raus, also das heißt hier raus folgt entsprechend das E mal D Modulo-Phi von N, also so oft Pi von N abzuziehen, wie es geht, kommt das gleiche raus, wie so oft ein Teiler von Pi von N abzuziehen, wie es geht, und einer der Teiler von Pi von N ist ja gerade Pi von Q, also das ist dasselbe wie E D Mod Pi von Q und bei der linken Seite, da wissen wir was da entsprechend rauskommt, da kommt nämlich gleich 1 raus, das heißt mit dem was hier eingeblendet ist, gilt dann also das C hoch D Modulo-Q zu rechnen, da klappt all das was vorher Modulo-N geklappt hat und da kommt dann also tatsächlich raus M hoch I mal D Modulo-Phi von Q hatten wir gerade uns überlegt, das ist das gleiche wenn ich da Modulo-Phi von N nehme, und das ist ja das gleiche wie 1, also das gibt dann gerade M hoch 1 und immer noch Modulo-Q am Ende, das heißt was da rauskommt ist gleich M Modulo-Q, ja das würde also bedeuten, dass wenn ich meine Nachricht nehme, ich kriege meine kodierte Nachricht entsprechend C, das gibt mir derjenige der mir was schicken möchte, und ich rechne das jetzt so zurück wie ich das auch sonst mache, indem ich hoch D nehme, und ich würde jetzt Modulo meine eine Primzahl nehmen und nicht Modulo-N, denn käme tatsächlich die unverschlüsselte Nachricht wieder raus Modulo-Q, das Problem an dem, wenn wir nur so weit wären, wäre ich müsste Modulo-Q rechnen statt Modulo-N, das heißt ich müsste diesen Fall separat abfangen und das ist sehr schwierig, wenn ich nicht weiß welche Nachricht mir geschickt wird, weiß ich nicht ob einer meiner Primzahlenden Teiler dieser Nachricht ist, und das zweite Problem ist das Q ist ja durchaus deutlich kleiner als das N, also wenn meine Nachricht die ist so gewählt, dass sie zwischen 0 und N-1 liegt, aber die muss nicht so gewählt sein, dass sie zwischen 0 und Q-1 liegen, das heißt dieses Modulo-Q rechnen, das könnte auf der Nachricht tatsächlich was ausmachen, also die Frage ist, warum ist es auch egal, also warum kommt auch das gleiche raus, wenn ich C hoch D Modulo-N rechne, warum kommt dann ebenfalls Groß-M Modulo Groß-N raus, das ist das was wir gerne hätten, wir hätten gerne diese eine Entschlüsselungsform, die wir einfach immer nehmen, und auch in dem Spezialfall, dass unsere Primfaktoren da irgendwie als Teiler der Nachricht mit vorgekommen sind, dann soll es trotzdem klappen, und das kriegen wir aber auch noch hin, denn aus dem was wir hier geschrieben haben, also aus dieser Geschichte hier, aus der folgt ja, dass C hoch D geteilt durch Q den selben Rest ergibt wie M geteilt durch Q, und das heißt aber insbesondere, dass C hoch D minus M, da habe ich, ja Sie wissen mit den Resten können wir rechnen, also egal ob ich den Rest vorher oder nachher rechne, C hoch D minus M und dann geteilt durch Q ist dasselbe wie C hoch D geteilt durch Mod Q minus M Mod Q, da kommt aber das gleiche raus, das heißt da kommt Mod Q einfach gleich 0 raus, also C hoch D hat den selben Rest bezüglich Q wie M hat, also hat die Differenz gar keinen Rest, das heißt Q teilt entsprechend C hoch D minus M, das heißt schreiben wir das wieder in dieser vielfachen Form, das heißt es gibt eine Vielfaches, es gibt ein L in Z, so dass C hoch D minus M, dass das gleich ist L mal Q, was ich gerne hätte wäre, dass C hoch D minus M gleich ein Vielfaches ist von P mal Q, denn ich möchte ja gerne C hoch D modulo groß N rechnen und dann groß M modulo N raushaben, das heißt was ich gerne hätte wäre C hoch D modulo groß N ist gleich M, dafür bräuchte ich, dass C hoch D minus M nicht gleich L mal Q ist, sondern gleich irgendein Vielfaches von P mal Q, und die Idee ist jetzt aber, dass wir in diesem L das P auch wieder als Teiler drin finden, denn wir sind ja damit gestartet, dass wir in dem Fall sind, dass unsere Nachricht groß M, dass die entsprechend, dass die geteilt wird von der Primzahl P, also wir sind in dem Fall, dass P unser M teilt, also ich hätte gerne das P in dem L wieder gefunden, auf der linken Seite steht C hoch D und M, in dem groß M steckt das P schon mal mit drin. Wie ist es mit dem C? Nun, wenn wir da zurück schauen, ich blätte ihn gerade mal zurück, ob ich ihn das schon mit einblättern kann, ich mach ihn das mal blau, noch mal als Screenshot, jetzt können Sie noch sehen, das was ich ihn jetzt blau umkringelt habe, das sagt uns ja gerade, dass M hoch E gleich K, P, Q plus C ist, das heißt Sie haben links die Nachricht groß M, da steckt P als Primfaktor mit drin, dann steckt die Nachricht hoch E genommen, dann steckt der Primfaktor P entsprechend E mal mit drin, in der linken Seite von diesem blau eingekästelten Formel. Auf der rechten Seite steht K mal P mal Q, da steckt P auch als Primfaktor drin und es steht C da, das heißt das C ist gleich M hoch E minus K, P, Q, M hoch E wird von P geteilt, K, P, Q wird von P geteilt, das heißt wegen diesem blau gekästelten Satz, wegen diesem blau gekästelten Formel, gilt auch P teilt C. Also das ist ein P teilt M und, nennen wir das Ding Sternchen, und aus diesem blauen Sternchen folgt auch P teilt groß C. Naja, aber das heißt in dieser Formel hier ist sowohl das C wird von P geteilt, als auch das M wird von P geteilt, dann muss auch die Differenz von P geteilt werden, also muss auch LQ von P geteilt werden, d.h. daraus folgt, dass P dann auch C hoch D minus M teilt, also gleich L mal Q teilt, Q ist aber eine Primzahl, die ungleich P ist, das heißt das Q kann P nicht als Primfaktor enthalten, also muss das L, das P als Primfaktor, enthalten. Das heißt also, das L muss P als Primfaktor enthalten, und das heißt, jetzt sehen Sie es nicht mehr, das stimmt, jetzt brauchen Sie es aber auch nicht mehr, Dankeschön, das heißt das L muss P als Primfaktor enthalten, und das heißt also, es existiert wiederum ein, ich glaube J hatten wir noch nicht verwendet, ein J in Z, sodass L gleich J mal P ist, und das bedeutet dann aber, dass C hoch D minus M, dass das das gleiche ist, wie L mal Q, und L war J mal P mal Q, und jetzt haben wir alles, was wir brauchen, C hoch D und M, unterscheiden sich dann auch nur um ein Vielfaches von PQ, und PQ war gerade groß N, das heißt, daraus folgt, dass C hoch D modulo groß N, das ist ja gerade, J mal groß N, das C hoch D modulo groß N, dasselbe ist wie groß M modulo groß N, und da das Kleine gleich N minus 1 ist, ist das gleich groß N. Also das heißt, dieselbe Verschlüsselungsform, auch für den Spezialfall, dass unsere Nachricht dummerweise von einer unserer geheimen Primfaktoren geteilt wird, auch dann funktioniert einfach unser ganz normaler Entschlüsselungsalgorithmus, das heißt, wenn Sie das RSA-Verfahren implementieren, dann müssen Sie sich nicht darum kümmern, ob die Nachricht von einem der Primfaktoren geteilt wird, oder nicht, nur der Beweis ist etwas umständlicher, weil Sie Euler-Fermat nicht sofort anwenden können, sondern Euler-Fermat auch den anderen Primfaktor anwenden müssen, und dann entsprechend ein bisschen rum argumentieren, dass es dann immer noch klappt. Ja, ein Fall ist noch offen, wir hatten gesagt, wenn wir die Nachricht haben, und wir haben das N gleich P mal Q, dann kann es sein, dass das ganze Teil erfremd ist, also unsere Nachricht enthält keinen der beiden Primfaktoren, unsere Nachricht könnte den einen Primfaktor enthalten, unsere Nachricht könnte aber auch den anderen Primfaktor enthalten, also Fall C noch, es könnte ja auch sein, dass der GGT von M und N gleich Q sein, und das folgt natürlich genauso wie in B, wir haben über P und Q nichts vorausgesetzt, welchen wir P und welchen wir Q nennen, ob wir den größeren Q, den kleineren P nennen oder umgekehrt, das heißt, wenn wir die beiden Primfaktoren andersrum benennen, dann heißt das Q jetzt einfach P und das P heißt Q, das heißt, dann folgt mit B auch entsprechend für diesen Fall, dass es funktioniert. Also C folgt aus B durch Vertauschung von P und Q. Ja, das heißt, dieses RSA-Verfahren, das funktioniert tatsächlich, Sie können also, wenn Sie auf die Art und Weise Ihren Schlüssel generiert haben, das E und das Dn generiert haben als Public Key, dann kann Ihnen immer jemand eine Nachricht schicken, indem er sagt, er nimmt sich die Nachricht M hoch E modulo groß M, dafür muss er nur die Nachricht kennen, die er in einem ganz kleinen Moment, die er Ihnen schicken will, und entsprechend kann das Ganze dann codieren, und Sie möchten mich wahrscheinlich bitten, das einzublenden, weil Sie mitschreiben, ja, also das heißt, wir können an der Stelle codieren, indem wir M hoch E mod N ausrechnen, wir haben die Nachricht, die möchten wir gerne codieren, das machen wir, indem wir sie hoch E nehmen und modulo N ausrechnen, was wir dafür nur brauchen, ist E und N müssen wir kennen, und wir können die Nachricht zurückrechnen, wir können die D codieren, indem wir das C, was wir kriegen, hoch D nehmen und dann noch mal modulo N rechnen, das heißt, wir kennen den Geheimschlüssel D, mit dem wir entsprechend das hoch E rechnen zurückrechnen können. Und zum Abschluss möchte ich gerne so ein bisschen Handwaving, da will ich wahrscheinlich mehr sprechen als schreiben, wenn meine Stimme da mithält, möchte ich Ihnen noch kurz einen Überblick geben, also was muss man jetzt machen, um das Ganze wirklich praktisch zu implementieren, an welchen Stellen bin ich Ihnen noch was schuldig geblieben, und wie könnte ein Angreifer jetzt probieren, dieses Verfahren zu knacken, also was brauchen wir, 242 Ausblick, Aufwand und Sicherheit von diesem RSA-Verfahren, also was muss ich machen, um das zu implementieren, und was müsste ein Angreifer machen, um das Ganze entsprechend zu knacken, also Aufwand und Sicherheit von RSA. Ja, überlegen wir uns erstmal, was müssten wir machen, um das wirklich rauszukriegen, also wir müssten diesen Public und Private Key, den müssten wir erzeugen, das E, D, das war ja unser Public Key, nicht E, D, E, N ist unser Public Key, das braucht jemand, um mir eine verschlüsselte Nachricht senden zu können, um eine Nachricht zu verschlüsseln, und was ich brauche, ist das D, N als Private Key, das brauche ich, damit ich entsprechend entschlüsseln kann, was brauche ich, um diese Paare zu generieren, also was muss ich machen, um diesen Public-Private-Key-Schlüsselpaare überhaupt erst mal zu generieren, ich musste mir zwei Primzahlen wählen, P und Q, und ich musste diese beiden Primzahlen, die musste ich miteinander multiplizieren, so habe ich das N gekriegt, also ich brauche eine Möglichkeit, Primzahlen zu generieren, und dann habe ich mir zu diesem N, ein teilerfremdes E noch wählen müssen, also so habe ich das N und das E entsprechend bekommen, das heißt, ich muss Primzahlen generieren können, und ich muss eine Zahl E, die da zu teilerfremd ist, generieren können, das ist wie gesagt der Punkt, dem bleibe ich Ihnen schuldig, Primzahltests, wie Sie sehr große Zahlen effizienter darauf testen können, ob Sie Primzahlen sind oder nicht, wie Sie Zahlen zufällig generieren können, die mit hoher Wahrscheinlichkeit Primzahlen sind, wie gesagt, da verweise ich Sie auf die Spezialvorlesung in der Kryptographie, das bleibe ich Ihnen schuldig, nur so viel, man macht es typischerweise andersrum in der Praxis, also man generiert sich nicht zwei Primzahlen, und dann generiert man sich ein E dazu, was zum Produkt der beiden Primzahlen teilerfremd ist, ich muss genau sagen, man muss nicht zum Produkt der Primzahlen teilerfremd sein, man muss zu V von groß N, also zu P-1 mal Q-N, dazu muss man teilerfremd sein, also Generierung der Schlüssel benötigt Primzahlen, also Prime, P und Q, und zu P-1 mal Q-1, das war ja gerade das, was als Euler-Schifffunktion von groß N vorkam, dazu ein teilerfremdes E. Und wenn ich das alles generiert habe, also ich habe zwei Primzahlen generiert, ich habe mir dazu ein teilerfremdes E generiert, dann kann ich mir damit das D aus dem erweiterten Euclid generieren, als das Multiplikativ inverse zu dem E, und dann habe ich alles, was ich brauche, das heißt, alles, was ich brauche, sind zwei Primzahlen, und zu diesem Produkt, die Primzahl minus eins genommen, ein teilerfremdes E. Wie macht man das in der Praxis? In der Praxis macht man das typischerweise so, dass Primzahlen zu generieren, da hat man sehr gute Verfahren, das heißt, was man in der Praxis typischerweise macht, ist man wählt das E zuerst, also man wählt zuerst ein E, und dann generieren wir solange P und Q, PQ' solange bis P minus eins mal Q minus eins, bis E teilerfremd sind, das können Sie nicht mehr lesen, also bis, ich schreibe immer bis teilerfremd. Ja, und das E, wenn man sich das zuerst vorgibt, das hat noch den Vorteil, man kann sich das E so wählen, dass das Hochehen nehmen möglichst einfach ist, Sie wissen, hoch eine Zahl zu nehmen, das können wir durch diese binäre Exponenzation relativ einfach machen, das heißt, in dem Moment, wo wir hoch eine große Zahl nehmen wollen, können wir stattdessen auch sagen, wenn die Zahl durch zwei teilbar ist, wir nehmen hoch die Hälfte dieser Zahl, und das, was dann rauskommt, das nehmen wir mal sich selbst, dann haben wir entsprechend auch hoch die große Zahl genommen. Auf die Art und Weise hatten wir uns überlegt, können wir hoch sehr große Zahlen relativ effizient dadurch berechnen, dass wir einfach weniger Multiplikationen brauchen, weil wir damit in jedem Schritt diese Zahl um die Hälfte reduzieren. Das klappte dann besonders gut, wenn die Zahlen, die vorkommen, gerade waren, weil sobald eine ungerade Zahl vorkam, brauchten wir dann doch ein dreier Produkt Zahl mal, ja, und dann entsprechend Zahlhochexponente minus eins, das konnten wir dann durch zwei Teilen in zwei Teile zerlegen. Das heißt, besonders einfach klappt das Ganze, wenn das E eine Zweierpotenz wäre. Also, wenn wir das E so wählen würden, zum Beispiel, E als eine Zweierpotenz wählen würden, 2 hoch 16, fast 2 hoch 16, ist das, was man in der Praxis tatsächlich sehr, sehr ruhig nimmt. Wenn ich E gleich 2 hoch 16 wählen würde, dann wäre die Sache sehr, sehr einfach. Dann könnte ich nämlich entsprechend bei dem, wenn ich hoch 2 hoch 16 nehmen will, dann ist das so, wie hoch 2 hoch 15 zu nehmen und die Zahlen mit sich selber zu multiplizieren, mal hoch 2 hoch 15 zu nehmen, ist wie hoch 2 hoch 14 zu nehmen, die Zahlen mit sich selber zu multiplizieren und so weiter. Das heißt, ich könnte diesen Exponenten immer durch zwei teilen, und es kämen immer noch gerade Zahlen vor. Ganz so einfach können wir es uns nicht machen, weil das Problem ist P minus eins, P ist eine Primzahl, das heißt P minus eins ist gerade, wenn P nicht gerade 2 ist, und Q minus eins, Q ist auch eine Primzahl, Q minus eins ist auch gerade, das heißt P minus eins mal Q minus eins ist immer durch zwei teilbar. Das heißt, eine Zweierpotenz ist nie Teilerfremd zu P minus eins, Q minus eins, und was man dann typischerweise macht, ist, man nimmt sich etwas, wo man diese geschickte Exponenzation durchführen kann und nur einmal auf eine ungerade Zahl trifft, nämlich ganz am Anfang, das heißt, in vielen Implementierungen steckt tatsächlich das gleiche E drin, der gleiche Public Key, nämlich einfach ein E hoch 2, E gleich 2 hoch 16 plus eins. Hat den Vorteil, dass Sie einmal durch dieses plus eins, müssen Sie einmal 2 mal 2 hoch 15, mal 2 hoch, mal E mal 2, E ist gleich einmal 2, mal 2 hoch 8, mal 2 hoch 8, würde entsprechend 2 hoch 16 geben, oder wenn Sie entsprechend hoch nehmen, könnten Sie es entsprechend, haben Sie immer gerade Zahlen, die vorkommen, bis auf das erste Mal. Das heißt, der Unterschied im Public Key ist tatsächlich bei vielen Implementierungen gar nicht in der Zahl hoch, die Sie nehmen, sondern nur die Zahl modulo, der Sie nehmen, denn in dem Groß n, da stecken dann die beiden Primzahlen entsprechend drin, das heißt, das Groß n ist das, was dann entsprechend zufällig gewählt wird, Sie generieren sich solange Primzahlen des P minus eins, Q minus eins, teilerfremd ist zu diesem E, und nehmen dann entsprechend die beiden Primzahlen, um als Produkt davon das Groß n zu bestimmen. Was müsste jemand machen, also das ist etwas, was man tatsächlich mit relativ wenig Aufwand implementiert bekommt. Was müsste jemand machen, um das RSA-Verfahren anzugreifen, also jetzt erstmal wirklich an mathematischen Angriffsmöglichkeiten, die man da hätte, also Angriffsmöglichkeiten, wie könnte man probieren, das Ganze zu knacken, oder wie könnte man probieren, das Ganze zurückzurechnen, ohne den Private Key zu kennen. Nun das erste, was man probieren könnte, wäre wirklich eine ganz direkte Attacke. Ich weiß ja, mein Schiffrad hat sich dadurch ergeben, dass der Klartext hoch e genommen wurde, modulo n. Also was wir probieren könnten wäre, wir berechnen Groß n aus der Kenntnis von C gleich m hoch e modulo Groß n. Ich weiß ja, wie mein Schiffrad zustande gekommen ist, jemand hat eine Zahl hoch e genommen und modulo n gerechnet, also probiere ich das hoch e nehmen, rückgängig zu machen. Hoch e nehmen rückgängig zu machen bedeutet, ich muss die ehte Wurzel nehmen, und ich muss das Ganze in dieser endlichen Menge von 0 bis n-1 machen. Das heißt, was ich hierfür brauche, ist die diskrete ehte Wurzel. Wenn es dafür ein effizientes Verfahren geben würde, um die ehte Wurzel zu bilden, dann wäre RSA hinfällig, weil dann könnte ich das hoch nehmen, einfach rückgängig machen. Das ist ja gerade das Problem mit der Multiplikation. Die Multiplikation, da gibt es ein effizientes Verfahren dazu, das rückgängig zu machen. Deswegen ist die Multiplikation kein gutes Private-Public Key-Verfahren. Da kriegen Sie mit einem erweiterten Euler-Algorithmus, kriegen Sie einfach das Multiplikativ inverse raus. Wenn das hier entsprechend auch so einfach wäre, würde RSA nix tauchen. Das heißt, der Trick ist, diskrete ehte Wurzel ist kein effizientes Verfahren bekannt. Das heißt, niemand weiß, wie man die ehte Wurzel berechnet, ohne ganz salopp gesagt einfach alle Zahlen durchzuprobieren. Proud Force geht immer, Sie können einfach alle m's durchprobieren, nehmen sich alle m's hoch e und gucken, wann kommt entsprechend das c dabei raus. Das heißt, Ihre Zahlen müssen so groß sein, dass einfaches Durchprobieren nicht machbar ist. Also hier ist kein effizientes Verfahren bekannt. Etwas genauer, das lernen Sie in den entsprechenden Vorlesungen über Komplexitätstheorie, wenn wir sagen, kein effizientes Verfahren. Die Art und Weise, wie man das misst, ist, man nimmt sich die Zahlen, die reingehen, als in Bitlänge gerechnet. Und dann ist es so, dass die Zahlen selber, die wachsen exponentiell mit der Bitlänge. Also wenn Sie acht Bit haben, können Sie entsprechend zwei hoch acht Zahlen damit kodieren. Wenn Sie 16 Bit haben, können Sie zwei hoch 16 Zahlen damit kodieren. Das heißt, das Ganze wächst exponentiell an. Mit jedem Bit, was Sie mehr kriegen, haben Sie einen Faktor zwei an Zahlen mehr, die Sie drin haben. Und wenn der Aufwand auch so steigt, dass Sie pro Bit, was dazukommt, ein konstanter Faktor in Ihrem Aufwand dazu geht, dann sagt man, der Aufwand wächst exponentiell. Und das ist deutlich mehr, als wenn Ihr Aufwand zum Beispiel nur polinomiell wachsen würde. Haben Sie in der Schule, Exponentialfunktion wächst schneller als jedes Polynom. Und der Unterschied zwischen effizienten Verfahren und nicht effizienten Verfahren, den misst man typischerweise dadurch, ob es Verfahren gibt, die polinomiell in der Bitlänge funktionieren oder die eben nicht polinomiell in der Bitlänge funktionieren. Und wenn die nicht polinomiell in der Bitlänge funktionieren, wenn die schneller anwachsen als jedes Polynom, dann geht man davon aus, dass man durch eine sehr große Bitlänge das Verfahren sehr, sehr sicher bekommt. Für die diskrete Ähte-Wurzel geht das entsprechend nicht. Die diskrete Ähte-Wurzel gibt es kein solches effizientes Verfahren, was polinomiell in der Bitlänge gehen würde. Was könnte ich noch machen? Ich muss ja nicht ganz gut vorwärts sein und sagen, ich nehme meine Verschlüsselung und mache einfach direkt die Verschlüsselung, das Hoche nehmen. Ich probiere direkt dieses Hoche nehmen, rückgängig zu machen. Ich könnte es ja auch geschickter probieren, ich weiß ja, dass derjenige, der D kodiert, ich weiß, dass der berechnet das zurück, indem er n gleich c hoch d modulo n ausrechnet. Also ich weiß, es gibt so ein D, sodass man die Nachricht durch c hoch d modulo n wieder zurückrechnen kann. Und das ist ja ein Public-Private-Key-Verfahren, das heißt, ich kann mir so viele Nachrichten verschlüsseln, wie ich will, ich kann mir meinen Klartext und verschlüssel ihn, das heißt, ich kann mir so viele Paare von Klartext Schifrad basteln, wie ich möchte. Insbesondere kann ich mir einen Klartext nehmen, m, ich bastel mir meinen Schifrad c, das Groß n kenne ich auch, das heißt, in dieser Gleichung m gleich c hoch d modulo n kenne ich alle Ausdrücke bis auf das D. Das heißt, ich könnte probieren, diese Gleichung, die da steht, nach dem D aufzulösen. Das heißt, ich könnte probieren, bestimme das D, also bestimme den Private-Key letztlich aus m gleich c hoch d mod n. Ja, was bräuchte ich dafür? Ich müsste eine Gleichung nach den Exponenten auflösen, das heißt, was ich hierfür bräuchte, wäre gerade der diskrete Logarithmus. Und auch dafür ist aber kein effizientes Verfahren bekannt. Also das heißt, direktes Zurückrechnen, hoch e nehmen, zurückrechnen, weiß man nicht, wie es geht, außer alles ausprobieren. Hoch d, also den privaten Schlüssel aus dieser Beziehung auszurechnen, aus einem Klartext Schifrad Paar, ebenfalls kein effizientes Verfahren bekannt, weil wir dafür den diskreten Logarithmus bräuchten. Das könnte man noch machen, man könnte noch probieren, dasselbe zu machen, was derjenige gemacht hat, der sich diesen privaten Schlüssel erzeugt hat. Der konnte sich den privaten Schlüssel ja dadurch erzeugen, dass er von dem e das Multiplikativ inverse bezüglich modulo phi von n genommen hat. Also was man ebenfalls probieren könnte, um das Ganze anzugreifen, wäre, wir probieren phi von n auszurechnen. Also Berechnung von phi von groß n aus groß n. Das heißt, alles was ich machen müsste, ist dieses groß n zu nehmen und ich müsste alle Zahlen zählen, die teilerfremd zu groß n sind. Und wenn ich die Anzahl kenne, kenne ich das phi von n. Und wenn ich phi von n kenne, dann kann ich mir das Multiplikativ inverse von e bezüglich modulo phi von n ausrechnen. Dann habe ich mir einen Privatkey aus dem Public Key berechnet. Weil sie ahnen, es ist kein effizientes Verfahren, all diese nicht teilerfremden Zahlen zu zählen. Das geht im Allgemeinen ebenfalls nicht, ohne sie wirklich alle Zahlen durchzugehen. Also kein effizientes Verfahren bekannt. Und der letzte, was noch gehen könnte, naja, wenn ich phi von n nicht direkt aus n ausrechnen kann, vielleicht kann ich so machen, wie derjenige, der seinen Privatkey erzeugt hat. Ich könnte probieren, das n in zwei Primzahlen zu zerlegen. Das heißt, was ich probieren könnte, wäre, zerlege mein groß n in p mal q. Denn wenn ich p und q kenne, dann kann ich phi von n durch p-1 mal q-1 berechnen. Dann kann ich mein Multiplikativ inverse modulo phi von n berechnen. Dann habe ich ebenfalls den Privatkey rausbekommen. Also das heißt, was wir brauchen, ist eine Primfaktorzerlegung und da ist ebenfalls kein effizientes Verfahren bekannt. Das heißt, wenn Sie hören, dass effiziente oder moderne Kryptographie darauf beruht, dass auch der Primfaktorzerlegung dafür kein effizientes Verfahren bekannt ist, dann ist das typischerweise das, was damit gemeint ist. Kein effizientes Verfahren bekannt. Und tatsächlich beruht die Sicherheit nicht nur auf der Primfaktorzerlegung. Dann gäbe es noch andere Angriffsmöglichkeiten. Wenn Sie die Eulerche-Phi-Funktion ohne die Primfaktorzerlegung bestimmen könnten, dann hätten Sie das Ganze auch dekodiert. Wenn Sie den diskreten Logarithmus oder das diskrete Wurzelziehen effizient durchführen könnten, hätten Sie das Verfahren entsprechend auch geknackt. Zum Glück ist das in all diesen Fällen aber nicht der Fall. Und es ist auch dadurch, dass das Verfahren relativ einfach ist. Wir können Ihnen das im ersten Semester beibringen und wirklich mit Beweisen beibringen. Dadurch, dass dieses Verfahren relativ einfach ist, ist das natürlich etwas, was auch jeder sich überlegen kann, wie er es angreifen kann. Und da bisher keine solchen Verfahren gefunden worden sind, kann man zumindest mit guter Wahrscheinlichkeit davon ausgehen, dass es da auch tatsächlich keine effizienten Verfahren gibt. Es ist allerdings streng mathematisch. Also wir haben einen streng mathematischen Beweis, dass bei der Dekodierung immer das Richtige rauskommt. Das habe ich Ihnen gezeigt. Wir haben keinen streng mathematischen Beweis, dass man einen dieser Punkte hier nicht effizient lösen könnte. Das heißt, alles, was man weiß, ist, man kennt kein effizientes Verfahren. Es gibt auch umgekehrt keinen Beweis, der einem zusichern würde, dass es kein effizientes Verfahren gibt. Also von daher bleibt da eine gewisse Restunsicherheit, die aber, wie gesagt, dadurch, dass Verschlüsselung ja jetzt auch schon einige Jahrzehnte eingesetzt wird und diese Dinge bisher nicht geknackt worden sind, zieht mir dann eine relativ große Sicherheit raus. Ja, und damit wäre es das für den ersten Teil der Vorlesung. Und ich danke Ihnen fürs Zuhören. Und jetzt geht es mit was Neuem weiter.